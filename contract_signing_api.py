#!/usr/bin/env python3
"""
API para gera√ß√£o de links de assinatura de contratos usando DocuSign e AWS S3

Este script permite:
1. Buscar contratos no bucket S3
2. Criar envelopes de assinatura no DocuSign
3. Gerar links de assinatura para retorno ao ManyChat

Uso:
python contract_signing_api.py --email "user@example.com" --name "Jo√£o Silva" [--contract "contrato.pdf"]

Argumentos:
--email: Email do signat√°rio (obrigat√≥rio)
--name: Nome do signat√°rio (obrigat√≥rio)
--contract: Nome espec√≠fico do contrato no S3 (opcional, usa o mais recente se n√£o especificado)
--return-url: URL de retorno ap√≥s assinatura (opcional, padr√£o: https://www.docusign.com)
"""

import argparse
import json
import sys
import logging
from docusign_esign import ApiClient
from docusign_esign.client.api_exception import ApiException

from app.jwt_helpers import get_jwt_token, get_private_key
from app.eSignature.examples.eg002_signing_via_email_s3 import Eg002SigningViaEmailS3Controller
from app.jwt_config import DS_JWT

# Importar Google Sheets helper
try:
    from shared.google_sheets_helper import GoogleSheetsHelper
    GOOGLE_SHEETS_AVAILABLE = True
except ImportError:
    GOOGLE_SHEETS_AVAILABLE = False
    print("‚ö†Ô∏è  Google Sheets integration not available (missing dependencies)")

SCOPES = [
    "signature", "impersonation"
]


def get_token(private_key, api_client):
    """Obt√©m token JWT do DocuSign"""
    # Call request_jwt_user_token method
    token_response = get_jwt_token(private_key, SCOPES, DS_JWT["authorization_server"], DS_JWT["ds_client_id"],
                                   DS_JWT["ds_impersonated_user_id"])
    access_token = token_response.access_token

    # Save API account ID
    user_info = api_client.get_user_info(access_token)
    accounts = user_info.get_accounts()
    api_account_id = accounts[0].account_id
    base_path = accounts[0].base_uri + "/restapi"

    return {"access_token": access_token, "api_account_id": api_account_id, "base_path": base_path}


def get_latest_contract_data():
    """
    Busca dados do contrato mais recente e extrai nome/email do nome do arquivo

    Returns:
        dict: Dados do contrato ou None se n√£o encontrar
    """
    logger = logging.getLogger(__name__)

    try:
        from app.aws_s3_helper import S3Helper
        from app.jwt_config import AWS_CONFIG

        s3_helper = S3Helper(
            access_key=AWS_CONFIG["access_key_id"],
            secret_key=AWS_CONFIG["secret_access_key"],
            region=AWS_CONFIG["region"],
            bucket_name=AWS_CONFIG["bucket_name"]
        )

        contract_data = s3_helper.get_latest_contract(AWS_CONFIG["contracts_folder"])
        return contract_data

    except Exception as e:
        logger.error(f"‚ùå Erro ao buscar contrato mais recente: {str(e)}")
        return None


def create_signing_envelope(signer_email=None, signer_name=None, contract_name=None, return_url="https://www.docusign.com", auto_extract=True, update_google_sheets=True):
    """
    Cria envelope de assinatura e retorna o link de assinatura

    Args:
        signer_email (str, optional): Email do signat√°rio (auto-extra√≠do se None)
        signer_name (str, optional): Nome do signat√°rio (auto-extra√≠do se None)
        contract_name (str, optional): Nome espec√≠fico do contrato
        return_url (str): URL de retorno ap√≥s assinatura
        auto_extract (bool): Se True, extrai nome/email do nome do arquivo mais recente
        update_google_sheets (bool): Se True, atualiza planilha Google Sheets com o link

    Returns:
        dict: Resultado com envelope_id e signing_url
    """
    logger = logging.getLogger(__name__)

    # Auto-extrair dados do contrato mais recente se necess√°rio
    if auto_extract and (signer_email is None or signer_name is None):
        logger.info("ü§ñ Ativando extra√ß√£o autom√°tica de dados do contrato...")
        contract_data = get_latest_contract_data()

        if contract_data:
            if signer_email is None and contract_data.get('extracted_email'):
                signer_email = contract_data['extracted_email']
                logger.info(f"üìß Email extra√≠do automaticamente: {signer_email}")

            if signer_name is None and contract_data.get('extracted_name'):
                signer_name = contract_data['extracted_name']
                logger.info(f"üë§ Nome extra√≠do automaticamente: {signer_name}")
        else:
            if signer_email is None or signer_name is None:
                return {
                    "success": False,
                    "error": "no_contract_data",
                    "message": "N√£o foi poss√≠vel extrair dados do contrato. Forne√ßa email e nome manualmente."
                }

    # Verificar se temos os dados necess√°rios
    if not signer_email or not signer_name:
        return {
            "success": False,
            "error": "missing_parameters",
            "message": "Email e nome do signat√°rio s√£o obrigat√≥rios"
        }

    logger.info("üîê Inicializando autentica√ß√£o DocuSign...")
    api_client = ApiClient()
    api_client.set_base_path(DS_JWT["authorization_server"])
    api_client.set_oauth_host_name(DS_JWT["authorization_server"])

    private_key = get_private_key(DS_JWT["private_key_file"]).encode("ascii").decode("utf-8")

    try:
        logger.debug("üîë Gerando token JWT...")
        jwt_values = get_token(private_key, api_client)
        logger.debug("‚úÖ Token JWT obtido com sucesso")
        logger.debug(f"üÜî Account ID: {jwt_values['api_account_id'][:10]}...")

        envelope_args = {
            "signer_email": signer_email,
            "signer_name": signer_name,
            "cc_email": "",  # N√£o usar CC por padr√£o
            "cc_name": "",
            "status": "sent",
            "return_url": return_url
        }

        args = {
            "account_id": jwt_values["api_account_id"],
            "base_path": jwt_values["base_path"],
            "access_token": jwt_values["access_token"],
            "envelope_args": envelope_args
        }

        logger.info("üì§ Criando envelope de assinatura...")
        logger.debug(f"üìß Email: {signer_email}, Nome: {signer_name}")
        logger.debug(f"üìÑ Contrato: {contract_name or 'mais recente'}")
        logger.debug(f"üîó Return URL: {return_url}")

        result = Eg002SigningViaEmailS3Controller.worker(args, contract_name)

        envelope_result = {
            "success": True,
            "envelope_id": result["envelope_id"],
            "signing_url": result["signing_url"],
            "message": "Link de assinatura gerado com sucesso"
        }

        # Atualizar Google Sheets se solicitado e dispon√≠vel
        if update_google_sheets and GOOGLE_SHEETS_AVAILABLE:
            try:
                logger.info("Updating Google Sheets with contract link...")

                # Preparar dados para Google Sheets
                sheets_data = {
                    'name': signer_name,
                    'email': signer_email,
                    'contract_filename': contract_name or 'contrato_auto.pdf',
                    'signing_link': result["signing_url"],
                    'status': 'Enviado'
                }

                # Inicializar Google Sheets helper
                sheets_helper = GoogleSheetsHelper()
                sheets_helper.add_or_update_contract_link(sheets_data)

                logger.info("Google Sheets updated successfully!")
                envelope_result["google_sheets_updated"] = True

            except Exception as e:
                logger.warning(f"Google Sheets update failed: {str(e)}")
                envelope_result["google_sheets_error"] = str(e)
                # N√£o falha a opera√ß√£o se Google Sheets falhar

        return envelope_result

    except ApiException as err:
        body = err.body.decode('utf8')
        logger.error(f"üö® Erro na API DocuSign: {body}")

        if "consent_required" in body:
            consent_url = get_consent_url()
            logger.warning("üîê Consentimento necess√°rio - gere URL de consentimento")
            return {
                "success": False,
                "error": "consent_required",
                "consent_url": consent_url,
                "message": "√â necess√°rio conceder consentimento para a aplica√ß√£o. Acesse a URL fornecida."
            }

        return {
            "success": False,
            "error": "api_error",
            "message": f"Erro na API do DocuSign: {body}"
        }

    except ValueError as err:
        logger.error(f"‚ùå Erro de valida√ß√£o: {str(err)}")
        return {
            "success": False,
            "error": "validation_error",
            "message": str(err)
        }

    except Exception as err:
        logger.error(f"üí• Erro desconhecido: {str(err)}", exc_info=True)
        return {
            "success": False,
            "error": "unknown_error",
            "message": f"Erro desconhecido: {str(err)}"
        }


def get_consent_url():
    """Gera URL de consentimento do DocuSign"""
    url_scopes = "+".join(SCOPES)

    # Construct consent URL
    redirect_uri = "https://developers.docusign.com/platform/auth/consent"
    consent_url = f"https://{DS_JWT['authorization_server']}/oauth/auth?response_type=code&" \
                  f"scope={url_scopes}&client_id={DS_JWT['ds_client_id']}&redirect_uri={redirect_uri}"

    return consent_url


def main():
    parser = argparse.ArgumentParser(description='API para gera√ß√£o de links de assinatura DocuSign com Google Sheets')
    parser.add_argument('--email', help='Email do signat√°rio (auto-extra√≠do se n√£o fornecido)')
    parser.add_argument('--name', help='Nome do signat√°rio (auto-extra√≠do se n√£o fornecido)')
    parser.add_argument('--contract', help='Nome espec√≠fico do contrato (opcional)')
    parser.add_argument('--return-url', default='https://www.docusign.com',
                       help='URL de retorno ap√≥s assinatura (opcional)')
    parser.add_argument('--debug', action='store_true', help='Ativar modo debug com logs detalhados')
    parser.add_argument('--no-auto', action='store_true', help='Desabilitar extra√ß√£o autom√°tica de dados')
    parser.add_argument('--no-sheets', action='store_true', help='Desabilitar atualiza√ß√£o do Google Sheets')

    args = parser.parse_args()

    # Configurar logging
    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    logger = logging.getLogger(__name__)

    logger.info("üöÄ Iniciando API de Assinatura DocuSign")

    # Mostrar par√¢metros fornecidos ou informar sobre extra√ß√£o autom√°tica
    auto_extract = not args.no_auto
    update_sheets = not args.no_sheets

    if auto_extract:
        logger.info("ü§ñ Modo autom√°tico: dados ser√£o extra√≠dos do contrato mais recente")
        if args.email:
            logger.info(f"üìß Email fornecido: {args.email}")
        if args.name:
            logger.info(f"üë§ Nome fornecido: {args.name}")
    else:
        logger.info("üîß Modo manual: usando apenas par√¢metros fornecidos")

    if args.contract:
        logger.info(f"üìÑ Contrato espec√≠fico: {args.contract}")
    else:
        logger.info("üìÑ Usando contrato mais recente")

    logger.info(f"üîó URL de retorno: {args.return_url}")

    if update_sheets and GOOGLE_SHEETS_AVAILABLE:
        logger.info("üìä Google Sheets: habilitado")
    elif update_sheets and not GOOGLE_SHEETS_AVAILABLE:
        logger.warning("üìä Google Sheets: depend√™ncias n√£o dispon√≠veis")
    else:
        logger.info("üìä Google Sheets: desabilitado")

    try:
        result = create_signing_envelope(
            signer_email=args.email,
            signer_name=args.name,
            contract_name=args.contract,
            return_url=args.return_url,
            auto_extract=auto_extract,
            update_google_sheets=update_sheets
        )

        if result["success"]:
            logger.info("‚úÖ Envelope criado com sucesso!")
            logger.info(f"üÜî Envelope ID: {result['envelope_id']}")
            logger.info(f"üîó Link de assinatura: {result['signing_url']}")
        else:
            logger.error(f"‚ùå Erro: {result['message']}")
            if 'error' in result:
                logger.error(f"üîç Tipo de erro: {result['error']}")

        # Output JSON para f√°cil integra√ß√£o
        print(json.dumps(result, ensure_ascii=False, indent=2))

        # Exit code baseado no sucesso
        sys.exit(0 if result["success"] else 1)

    except Exception as e:
        logger.error(f"üí• Erro cr√≠tico: {str(e)}", exc_info=True)
        error_result = {
            "success": False,
            "error": "critical_error",
            "message": f"Erro cr√≠tico: {str(e)}"
        }
        print(json.dumps(error_result, ensure_ascii=False, indent=2))
        sys.exit(1)


if __name__ == "__main__":
    main()
